<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Maurício Witter | RSS Feed</title>
        <link>https://rwietterc.xyz</link>
        <description>RSS feed for Maurício Witter blog</description>
        <lastBuildDate>Mon, 07 Aug 2023 20:15:37 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Feed for Node.js</generator>
        <language>pt-BR</language>
        <image>
            <title>Maurício Witter | RSS Feed</title>
            <url>https://rwietterc.xyz/icons/mstile-310x310.png</url>
            <link>https://rwietterc.xyz</link>
        </image>
        <copyright>All rights reserved 2023, Maurício Witter</copyright>
        <atom:link href="https://rwietterc.xyz/rss.xml" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[Um paralelo entre Programação Declarativa e Programação Imperativa]]></title>
            <link>https://rwietterc.xyz/blog/article/um-paralelo-entre-programacao-declarativa-e-programacao-imperativa</link>
            <guid>um-paralelo-entre-programacao-declarativa-e-programacao-imperativa</guid>
            <pubDate>Mon, 17 Jul 2023 15:13:39 GMT</pubDate>
            <description><![CDATA[Quais são os trade-offs entre o Paradigma Imperativo e o Paradigma Declarativo, princípios e uso]]></description>
            <content:encoded><![CDATA[<h2>Introdução</h2>
<p>As linguagens de programação podem ser classificadas de diversas formas, podem ser classificadas por Type System forte ou fraco; pelo nível de abstração (Machine code, Low level Assembler ou High level); se são compiladas ou interpretadas, ou por Paradigmas (Orientação a Objetos, Funcional, Procedural, Lógico, Imperativo, Declarativo entre outros). Neste artigo falaremos sobre o Paradigma Imperativo e Declarativo.</p>
<p>Entender o que são os paradigmas de programação, suas características vai ajudar você a entender melhor outros paradigmas como o Paradigma Funcional, Lógico, ou Orientado a Objetos, pois todos eles tem alguma similaridade com os paradigmas declarativo, declarativo ou ambos.</p>
<p>O Paradigma Imperativo foi o primeiro estilo de codificação que surgiu, com as primeiras linguagens de estudo short code. Já o estilo declarativo começou com a linguagem LISP (1958), com o Prolog (1972), e funcionais como o Haskell (1990).</p>
<p>No lado das linguagens imperativas temos, por exemplo, FORTRAN, ALGOL, Pascal, Ada e C entre outras, já no lado da linguagens declarativas temos, por exemplo: HTML, CSS, YAML e SQL. As linguagens JavaScript, Java, PHP e Rust, por exemplo, são multiparadigma e o estilo depende de como você escreve, mas nenhuma delas é puramente declarativa.</p>
<h2>Estilo de Programação Imperativo</h2>
<p>O estilo imperativo concentra-se em como executar o código detalhe a detalhe e define o fluxo de controle de como instruções alteram o estado de um programa. Para ficar mais claro, o código imperativo ordena comandos ao computador, diz exatamente o que precisa fazer, como precisa fazer e em que ordem exata precisa executar.</p>
<p>A exemplo, o código abaixo é um algoritmo de ordenação chamado de bubble Sort que percorre o array <code>n^2</code> fazendo a troca dos elementos até ordená-lo completamente. Nesse código há a construção da lógica e fluxo de controle, além da mutabilidade do array.</p>
<p><img src="https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0a640f32-3aa6-4420-a048-16e4174e1a81_1348x1350.png" alt="bubble sort"></p>
<p>O código imperativo é interessante para programação de código de baixo nível para o qual existem poucas ou nenhuma abstração. O código fica extremamente verboso, ruim para depurar, ler e para dar manutenção. Em um código imperativo há muitos loops, condicionais e mutações de estado que facilmente resultam em bugs.</p>
<p>Assim sendo, a programação imperativa é mais adequada para tarefas onde é importante controlar o estado do programa e gerenciar o fluxo de execução.</p>
<p>Vamos calcular o fatorial de um número natural positivo, cuja fórmula está na imagem abaixo.</p>
<p><img src="https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff5c2b102-a99c-45d4-a8ee-71d106821de5_487x157.png" alt="fatorial"></p>
<p>No fatorial imperativo, avaliamos se <code>n</code> é menor ou igual a zero e retornamos 1, do contrário fazemos um loop até <code>n-1</code> e multiplicamos o valor de <code>n</code> pelo índice fazendo a mutabilidade de <code>n</code>, ao final retornamos <code>n</code>. Nesse código criamos a lógica de calcular o fatorial de <code>n</code> e o fluxo de controle.</p>
<p><img src="https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F36ca5586-ae84-49f3-9be8-23b7b7e716d9_1040x630.png" alt="fatorial imperativo"></p>
<h3>Características do código Imperativo</h3>
<ul>
<li>Execução sequencial;</li>
<li>Estado mutável;</li>
<li>Gerenciamento manual de memória;</li>
<li>Não-determinístico.</li>
</ul>
<h3>Vantagens</h3>
<ul>
<li>Domínio explícito sobre o fluxo de controle;</li>
<li>Eficiência em uso de memória (se utilizado corretamente);</li>
</ul>
<h3>Desvantagens</h3>
<ul>
<li>Código verboso;</li>
<li>Mutabilidade de estado;</li>
<li>Efeitos colaterais.</li>
</ul>
<h2>Paradigma Declarativo</h2>
<p>O Paradigma declarativo, por outro lado, é um modelo de abstração de alto nível. Nesse estilo, declara-se o que deve ser computado ao invés de como deve ser computado, delegamos a implementação de controle para a linguagem.</p>
<p>Assim, a programação declarativa é como escrever um mapa detalhado para chegar a um destino. Você define o objetivo e descreve as etapas necessárias para alcançá-lo, permitindo que o computador determine a melhor rota e execute as ações correspondentes, sem precisar se preocupar com os detalhes de como cada passo é realizado.</p>
<p>Muitas linguagens que aplicam esse estilo tentam eliminar os efeitos colaterais descrevendo o que o programa deve realizar em termos do domínio do problema, em vez de descrever como realizá-lo como uma sequência das primitivas da linguagem de programação.</p>
<p>Conforme R. Kowalski em Communications of the ACM, Volume 22, Issue 7, July 1979, <em>um algoritmo é composto pela lógica e pelo fluxo de controle. Na programação declarativa, a linguagem tende a abstrair a fluxo de controle e deixar para o programador desenvolver a lógica</em>.</p>
<p><img src="https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F649d082d-40e8-4567-b23f-3779291ec802_452x59.png" alt="algorithm"></p>
<p>Lloyd, JW. no artigo Practical advantages of declarative programming, explica que a programação declarativa pode ser entendida como “Forte” e “Fraca”. Isto é, no sentido “Forte”, o programador só fornece a lógica do que precisa e no sentido “Fraco”, o programador precisa fornecer a lógica e estender o fluxo de controle para computar o resultado esperado.</p>
<h3>Princípios da Programação Declarativa</h3>
<p>Para alcançar o estilo declarativo de programação, é necessário que alguns conceitos sejam aplicados. Os principais princípios deste paradigma são: <em>Stateless</em>, <em>Transparência referencial</em>, <em>Abstração</em> e <em>Ausência de efeitos colaterais</em>.</p>
<p><img src="https://i.imgur.com/aJz3ZYr.png" alt="pilares da programação declarativa"></p>
<h4>Stateless</h4>
<p>Em uma linguagem onde todos os dados são imutáveis, aplica-se o conceito de stateless. Isso significa que, uma vez que uma variável é atribuída, seu valor não pode ser alterado. Em vez disso, qualquer manipulação ou transformação de dados envolve o retorno de uma cópia dos valores originais transformados, de forma que os valores originais sem mantenham intactos. Em outras palavras, não fazemos a persistência dos dados entre as chamadas de execuções. Em JavaScript, funções como <code>map</code>, <code>filter</code> e <code>flatMap</code>são stateless e funções como <code>sort</code> são stateful.</p>
<blockquote>
<p>Uma função sem estado é aquela que não depende ou manipula o estado de contexto mais amplo. Ele pega tudo o que precisa como parâmetro e retorna um resultado, sem efeitos colaterais e nada armazenado entre as chamadas de execuções.</p>
</blockquote>
<p>Conforme Nick Samoylov em <a href="https://www.oreilly.com/library/view/introduction-to-programming/9781788839129/50f54a6f-dd25-40bc-89d2-31b73d95b6b7.xhtml">Introduction to Programming</a>, as operações sem estado geralmente não representam um problema ao alternar de um fluxo sequencial para um paralelo. Cada elemento é processado de forma independente e o stream pode ser dividido em qualquer número de substreams para processamento independente. Ou seja, o stateless acaba com bugs e race conditions em ambientes multithreading, não há razões para usar locks para sincronizar eventos dependentes.</p>
<h4>Transparência Referencial</h4>
<p>O valor de uma aplicação de função independe do contexto em que ocorre, isto é, dado um input a função deve retornar sempre o mesmo resultado. Por isso, a função deve ser independente do contexto, de forma que não use variáveis ou estados globais.</p>
<p>A função <code>add</code> não é referencialmente transparente pois dado o mesmo argumento, ela produz resultados diferentes:</p>
<pre><code>let total = 0

const add = a => total += a

const r1  = add(1) // 1
const r2  = add(1) // 2
</code></pre>
<p>Uma função ou expressão é referencialmente transparente se puder ser substituída por seu valor sem alterar o comportamento do programa.</p>
<h4>Abstração</h4>
<p>A abstração é um dos principais senão o principal princípio do Paradigma Declarativo, é a primeira coisa que vem a mente quando pensamos nela. Como já foi dito, dizemos o que queremos e não como queremos, assim delegamos a responsabilidade do que fazer para a linguagem de programação e apenas descrevemos como queremos o resultado a partir de determinada entrada.</p>
<p>Existem linguagens puramente declarativas, linguagens hibridas e multiparadigmas. YAML, SQL, HTML e XML são exemplos de linguagens puramente declarativas. Linguagens puramente funcionais ou lógicas como Haskell e Prolog, respectivamente, são hibridas pois apesar de ter seus próprios paradigmas (funcional e lógico) enfatizam a programação declarativa. Já as linguagens como Javascript, Java, PHP são multiparadigma, elas incluem algumas abstrações declarativas mas também incluem instruções imperativas e não opinam sobre qual meio usar.</p>
<h4>Ausência de efeitos colaterais</h4>
<p>Efeitos colaterais são alterações de estado ou execução de funções que não estão diretamente ligadas com a produção do resultado esperado de uma função. O Paradigma declarativo tem como objetivo eliminar as mudanças de estado em variáveis globais ou objetos compartilhados. Em vez disso, ela se concentra em avaliar expressões e produzir resultados imutáveis, o que ajuda a evitar problemas relacionados a estado e concorrência.</p>
<p>A função <code>doSomething</code> é considerada referencialmente transparente porque sempre retorna o mesmo valor de saída para uma determinada entrada, e não depende de nenhum estado externo. No entanto, apesar de ser referencialmente transparente, a função possui um side effect, ou seja, uma ação colateral que ocorre além da simples computação do valor de retorno, o side effect não faz parte da computação do valor de retorno da função, mas pode ter efeitos observáveis fora do escopo da função.</p>
<pre><code>const doSomething = (arg) => {
  console.log("something");
  return arg;
}
</code></pre>
<h3>Características do código Declarativo</h3>
<ul>
<li>Stateless (estado interno não é relembrado entre chamadas);</li>
<li>Determinístico (as mesmas chamadas produzem os mesmos resultados);</li>
<li>Paralelismo (execução de múltiplas tarefas simultaneamente);</li>
<li>Transparência Referencial (uma expressão pode ser substituída por seu valor sem afetar o comportamento);</li>
<li>Modelo semântico claro e conciso;</li>
<li>Abstrações de alto nível;</li>
<li>Independência.</li>
</ul>
<h3>Vantagens</h3>
<ul>
<li>Legibilidade;</li>
<li>Concisão;</li>
<li>Recuperação de erros;</li>
<li>Reutilização;</li>
<li>Comutatividade;</li>
<li>Sem efeitos colaterais;</li>
<li>Idempotência.</li>
</ul>
<h3>Desvantagens</h3>
<ul>
<li>Baixo nível de controle;</li>
<li>Dificuldades de programação com estado (Stateful).</li>
</ul>
<h2>Use Cases</h2>
<p>Você como Engenheiro de Software precisa conhecer bem as diversas classificações de linguagens e suas tecnologias para fazer boas escolhas e evitar tempo e dinheiro perdido. Não existe bala de prata, portanto é necessário conhecer as caraterísticas em geral. Aqui estão alguns casos de uso para cada estilo, embora existem muitos outros cenários.</p>
<h3>Paradigma Imperativo</h3>
<ul>
<li>Sistemas de baixo nível: programação de sistemas de baixo nível, como drivers de dispositivo, sistemas operacionais e firmware. Essas tarefas requerem manipulação direta de locais de memória e registros de hardware, sendo melhor realizado usando um estilo imperativo.</li>
<li>Jogos e simulações: jogos e simulações geralmente envolvem algoritmos complexos e atualizações em tempo real, sendo mais fáceis de expressar usando um estilo imperativo. A programação imperativa fornece controle explícito sobre o fluxo do programa, tornando mais fácil escrever mecanismos de jogo eficientes e simulações físicas.</li>
<li>Operações de E/S: a programação imperativa é adequada para tarefas que envolvem muitos estados mutáveis ​​e efeitos colaterais, como operações de E/S. Programas imperativos podem manipular diretamente locais de memória e registros de dispositivos, tornando-os adequados para essas tarefas.</li>
</ul>
<h3>Paradigma Declarativo</h3>
<ul>
<li>Desenvolvimento Web: a programação declarativa é frequentemente usada no desenvolvimento Web, onde HTML, CSS e outras linguagens de marcação são usadas para definir a estrutura e a aparência das páginas da Web. A programação declarativa permite que os desenvolvedores especifiquem a aparência da página, em vez de como obter essa aparência.</li>
<li>Processamento de dados: a programação declarativa é adequada para tarefas de processamento de dados, como consultar bancos de dados e manipular grandes conjuntos de dados. Linguagens de programação declarativas como SQL fornecem uma interface de alto nível para interagir com dados, tornando mais fácil escrever consultas e transformações complexas.</li>
<li>Programação funcional: a programação funcional enfatiza o uso de funções puras e estruturas de dados imutáveis. A programação funcional é adequada para tarefas que exigem muita simultaneidade ou paralelismo, pois funções puras não têm efeitos colaterais e podem ser executadas em paralelo com segurança.</li>
</ul>
<h2>Estado da Arte</h2>
<blockquote>
<p>A crescente popularidade das linguagens de programação declarativas decorre da simplicidade inerente do paradigma, cujo alto nível de abstração garante estilos de programação legíveis por humanos. — MOTTOLA A.. Design and implementation of a declarative programming language in a reactive environment. 2005.</p>
</blockquote>
<p>Muitas das linguagens imperativas começaram a trazer novos recursos na última década para o estilo declarativo. Um exemplo é o Java 8 que trouce uma nova API para Streams para operar em coleções usando expressões lambda abstraindo o código imperativo.</p>
<p>No Front-end também ganhamos muito mais produtividade e segurança com os frameworks declarativos que surgiram nos últimos anos, como o React, o Vue, o Angular, o Next, o Nuxt entre outros.</p>
<p>Na área de cloud-computing, várias ferramentas no estilo declarativo como o Terraform, Ansible, Docker, Kubernetes auxiliam a colocar aplicações em produção com escalabilidade, segurança e confiabilidade, fazendo o CI/CD.</p>
<h2>Conclusão</h2>
<p>À medida que a programação declarativa continua a evoluir, é provável que ela desempenhe um papel cada vez mais importante no futuro do desenvolvimento de software. Portanto, aprender sobre programação declarativa pode ser um investimento valioso para qualquer desenvolvedor que deseja melhorar sua habilidade em criar código de qualidade.</p>
<p>Se você chegou até aqui, espero que tenha tido uma ótima leitura e que esse conteúdo possa ter lhe ajudado de alguma forma. Obrigado por ler! Qualquer dúvida, agregação ou correção, <a href="https://twitter.com/rwietter">envie-me uma dm no twitter </a>.</p>
<h2>Referências</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Declarative_programming#:~:text=Declarative%20programming%20is%20a%20non,by%20a%20declarative%20programming%20style.">Declarative Programming</a></li>
<li><a href="https://dl.acm.org/doi/10.1145/359131.359136">Algorithm = logic + control</a></li>
<li><a href="https://www.cse.chalmers.se/~oloft/Papers/wm96.pdf">A Note on Declarative Programming Paradigms and the Future of Definitional Programming</a></li>
<li><a href="https://research-information.bris.ac.uk/en/publications/practical-advantages-of-declarative-programming">Practical advantages of declarative programming</a></li>
<li><a href="https://codedocs.org/what-is/declarative-programming">CodeDocs - Declarative programming</a></li>
<li><a href="https://blog.ndepend.com/imperative-programming-in-depth/">Imperative Programming in Depth</a></li>
</ul>
]]></content:encoded>
            <author>mauriciobw17@gmail.com (Maurício Witter)</author>
            <category domain="https://rwietterc.xyz">tech</category>
            <enclosure length="0" type="image/jpeg" url="https://res.cloudinary.com/ddwnioveu/image/upload/v1677368314/alexander_ant_r7xd_S9hj_YYE_ae767132f4.webp"/>
        </item>
        <item>
            <title><![CDATA[Preferir a duplicação sobre a abstração é realmente o melhor caminho ?]]></title>
            <link>https://rwietterc.xyz/blog/article/preferir-a-duplicacao-sobre-a-abstracao-e-realmente-o-melhor-caminho</link>
            <guid>preferir-a-duplicacao-sobre-a-abstracao-e-realmente-o-melhor-caminho</guid>
            <pubDate>Mon, 29 May 2023 01:45:54 GMT</pubDate>
            <description><![CDATA[A duplicação de código é algo muito ruim, uma abstração confusa é tão ruim quanto. Então qual seria a melhor abordagem para isso ?]]></description>
            <content:encoded><![CDATA[<p>Hoje vamos falar um pouco do princípio do desenvolvimento de software DRY (Don't Repeat Yourself) e suas implicações. O DRY é um princípio relacionado duplicação de código e abstrações. Falaremos sobre o conceito de Rule of Three proposto por <a href="https://martinfowler.com/">Martin Fowler</a> no seu livro Refactoring, falaremos sobre o conceito AHA (Avoid Hasty Abstractions) proposto por <a href="https://kentcdodds.com/">Kent C. Dodds</a> e, também, sobre conceito <a href="https://dev.to/wuz/stop-trying-to-be-so-dry-instead-write-everything-twice-wet-5g33">WET</a> (Write Everything Twice) proposto por <a href="https://dev.to/wuz">Conlin Durbin</a>.</p>
<p>Antes de tudo, vamos ver um exemplo do que seria duplicação de código para entender a existência desses conceitos.</p>
<p>A duplicação de código (a.k.a copiar/colar), nada mais é do que <strong>repetir o mesmo código em dois ou mais locais da base de código</strong>, essa duplicação traz consigo uma <strong>série de problemas</strong>, entre eles, a <strong>redundância de código, bugs no código repetido em diferentes componentes e a criação de bugs ao dar manutenção em uma das duplicações e esquecer a outra</strong>.</p>
<p>Em Ciência da Computação, <strong>a abstração é a simplificação de conceitos complexos e gerais em uma interface simples</strong>, tornando-os mais fáceis de entender e manipular em diferentes contextos.</p>
<h2>O problema da duplicação</h2>
<p>Suponha que temos 4 botões com CSS repetido em cada um deles, aí chega um requisito para mudar o background do botão e quem vai dar manutenção é outro desenvolvedor que não sabe se o código está repetido, onde está repetido e quantas vezes está repetido, já viu o problema não é ? Teremos botões de cor <code>#XXX</code> e botões de cor <code>#YYY</code>.</p>
<p>Agora, <strong>imagine se o cenário não for um simples botão, mas algo crítico para o software</strong> como a geração de JSON Web Token no login. Se esse código estiver repetido e alterarmos algo em um local em outro não, podemos ter problemas de vulnerabilidades ou diversos outros bugs que dependem do token.</p>
<p>A abstração errada, na realidade não passa de um código confuso e mal escrito. A abstração errada é uma abstração que não deveria existir. Então, seria melhor deixar o código repetido ao invés de fazer uma abstração complexa ? Talvez! Mas na maioria das vezes é apenas um erro de implementação ao definir várias responsabilidades a ela ou abstrair conhecimentos distintos.</p>
<h2>Princípios gerais</h2>
<p>Então, quando devemos duplicar código e quando devemos abstrair ? Essas perguntas tem muitas respostas, mas nenhuma é realmente um padrão convencional que todos os desenvolvedores adotam.</p>
<h3>Don't Repeat Yourself</h3>
<p>O DRY foi um princípio formulado por Andy Hunt e Dave Thomas, no livro <a href="https://www.amazon.com.br/Pragmatic-Programmer-Journeyman-Master/dp/020161622X">The Pragmatic Programmer</a>. Conforme os autores, o DRY surgiu para tentar resolver Os Males da Duplicação (The Evils of Duplication). Se você tem código duplicado, você precisa lembrar-se onde duplicou, mas não é uma questão de saber se você vai se lembrar: é uma questão de quando você vai esquecer, e a surpresa não será nada agradável quando acontecer.</p>
<p>Em outras palavras, quando você precisa alterar alguma coisa e o código está repetido por N vezes na sua base de código, então você terá que alterar em N lugares e isso nos leva ao problema descrito na seção 1.</p>
<blockquote>
<p>“Cada fragmento de conhecimento deve ter uma representação única, inequívoca e autoritária dentro de um sistema.” (The Pragmatic Programmer).</p>
</blockquote>
<p>Conforme Hunt e Thomas, <strong>um código que representa um conhecimento deve ter uma representação única, inequívoca e autoritária dentro de um sistema</strong>. Isso significa que DRY não é apenas sobre não duplicar código, mas é, sobretudo, conhecimento.</p>
<p>Bem, mas o que isso significa ? Significa que dois códigos duplicados podem ser iguais no momento, mas que podem crescer com seus próprios requisitos e de forma diferente, ou seja, temos dois fragmentos com representações únicas de conhecimento, nesse caso não faz sentido criar uma abstração pois não viola o principio DRY e você pode acabar tendo uma abstração que representa instâncias de conhecimentos diferentes.</p>
<p>O DRY não específica quando é a hora de abstrair uma duplicação ou quando não abstrair, você simplesmente não deve repetir o mesmo conhecimento. Muitos desenvolvedores fazem abstrações precipitadas e acabam tendo uma abstração complexa que tem muitas responsabilidades, tornando o código pouco legível, manutenível e testável.</p>
<p><em>Isso nos leva ao Rule of Three…</em></p>
<h3>Rule of Three</h3>
<p>Esse conceito foi proposto por Martin Fowler em seu livro Refactoring.</p>
<p>Você deve estar se perguntando o porquê de <strong>três</strong> ser especial. Geralmente você acaba tendo duas duplicações com uma ou outra leve particularidade e pode ser mantida assim caso você não saiba os requisitos futuros, mas quando há três duplicação é muito comum ter mais duplicações.</p>
<blockquote>
<p>“A primeira vez que você faz algo, você simplesmente faz. Na segunda vez que você faz algo semelhante, você pode ter calafrios com a duplicação, mas faz a duplicação de qualquer maneira. Na terceira vez que você fizer algo semelhante, você refatorará” (Martin Fowler - Refactoring).</p>
</blockquote>
<p>Rule of Three diz que você pode duplicar o código por duas vezes, mas se você tiver que repetir pela terceira vez, então é hora de refatorar.</p>
<h3>Write Everything Twice</h3>
<p>WET se assemelha ao conceito Rule of Three, WET tenta se afastar de otimizações prematuras e permite que você possa repetir código duas vezes mas não três. No entanto, aqui o sistema pode ser entendido como algo mais abstrato e a abstração depende do contexto.</p>
<p>Por exemplo, se você tem botões que se repetem em diferentes páginas, faz sentido você abstrair em um único componente. No entanto, se você tem duas páginas como /blog e /listas que recebem um conjunto de dados e renderizam o título e descrição, não há essa necessidade pois são componentes de conhecimento distintos.</p>
<p>Conlin Durbin enfatiza que em caso de duplicação, você deve comentar sobre elas, para quando ocorrer um problema ou tiver que fazer uma abstração, seja mais fácil encontrá-las.</p>
<h3>Avoid Hasty Abstractions</h3>
<p>Enfim, chegamos ao AHA que se pronúncia “Aha!” e pode se entendido como “Evite abstrações precipitadas”. Esse conceito foi proposto por Kent C. Dodds em um <a href="https://kentcdodds.com/blog/aha-programming">artigo</a> no ano de 2020. Na mesma linha, Dodds sugere que <strong>devemos evitar abstrações precipitadas pois não sabemos todos os requisitos de um sistema de antemão</strong>, tanto que pode mudar e evoluir e você acaba com uma <a href="https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction">abstração errada</a>, conforme cita Sandi Metz.</p>
<blockquote>
<p>“Otimize primeiro, faça a mudança depois.” (Kent C. Dodds - AHA).</p>
</blockquote>
<p>AHA da mais flexibilidade e não impõe regras de duplicações para refatorar e abstrair, mas ressalta que a importância do DRY para não virar um caos absoluto. Primeiramente, diante de duplicações, deve-se <strong>otimizá-las antes de mudar no sentido de abstrair com clareza</strong>. Quanto a questão de quando mudar, <strong>você pode mudar quando sentir-se confiante com os casos de uso</strong>.</p>
<h2>Adaptação</h2>
<p>A duplicação de código incorre em um custo muito alto na maioria das vezes, mesmo que seja no máximo duas duplicações. Talvez, se o problema é abstração mal feita, então o problema é de implementação. Algo que deve resolver isso é entender como DRY trata conhecimento, para não criarmos abstrações com diversas responsabilidades. Ou seja, se você tem uma abstração que está tomando rumos diferentes, caia fora dessa abstração e faça outra que atende aos requisitos do novo recurso.</p>
<p>Por exemplo, temos o <strong>ComponenteA</strong> e o <strong>ComponenteB</strong>, eles são uma duplicação de código com um padrão em comum e mesmo conhecimento, então criamos a AbstraçãoX de forma simples e flexível por padrão (Imagem 1). Digamos que o ComponenteB precisa mudar e é preciso modificar a AbstraçãoX, de tal modo que adicionamos mais responsabilidade e que não é usada no ComponenteA, ou seja, isso já <strong>deixou de ter o mesmo conhecimento</strong> e possivelmente trará problemas futuros. Para resolver isso, vamos separar a AbstraçãoX em AbstraçãoX e AbstraçãoY ou desfazer as abstrações e retornar aos Componentes A e B.</p>
<p><img src="https://res.cloudinary.com/ddwnioveu/image/upload/v1685323229/b55d6170_0684_4f19_9f93_480f96b242b3_1344x1306_a053b70020.webp" alt="b55d6170-0684-4f19-9f93-480f96b242b3_1344x1306.webp">
.</p>
<p>Dessa forma, podemos resolver a questão de abstrair sem ter que lidar duplicações. Particularmente, as duplicações em uma base de código grande são bem custosas. Assim, para lidarmos com abstrações erradas, analisamos o contexto e o conhecimento, quando não faz mais sentido essa abstração, removemos a abstração. Não precisamos ter que duplicar código uma, duas ou três vezes a espera de abstrair e evitar dores de cabeça.</p>
<p><strong>Essa é só outra visão, portanto, fica a sua escolha testar e verificar qual se sai melhor pra você.</strong></p>
<h3>Além disso…</h3>
<p><strong>Evite abstrações excessivamente genéricas</strong>, as abstrações podem ser tão genéricas que perdem sua utilidade. Por exemplo, criar uma abstração de "Animal" para um sistema que só tem um tipo de objeto “Cachorro” pode ser excessivamente genérico e não agregar valor. As abstrações devem ser específicas e relevantes para o problema que se está tentando resolver.</p>
<p><strong>Evite a duplicação de código em testes</strong>, seus testes devem ser tão DRY quanto possível e evite duplicar código em vários testes.</p>
<p>Para a evolução do software, <strong>as abstrações devem ser flexíveis o suficiente para lidar com mudanças no sistema</strong> e permitir que o software evolua sem muita dor.</p>
<p>No que tange a legibilidade do código, <strong>as abstrações devem tornar o código mais legível e não o contrário</strong>.</p>
<h2>Para concluir</h2>
<p>Criar abstrações é complicado e requer um bom entendimento do problema a ser resolvido. Se uma abstração não for bem projetada, ela pode acabar sendo mais difícil de entender e manter do que o próprio código duplicado.</p>
<p>No entanto, isso não significa que a duplicação de código seja a melhor alternativa. A duplicação pode levar a problemas de manutenção, como correções duplicadas ou código obsoleto, além de dificultar a leitura e a compreensão do código. A duplicação aumenta o risco de erros, pois, se uma correção é feita em um lugar, pode ser esquecido de ser feito em outro lugar onde o código é duplicado.</p>
<p>A solução para evitar a duplicação de código e ainda assim criar abstrações úteis é encontrar o equilíbrio certo entre abstração e detalhes de implementação. É importante pensar em como a abstração pode ser útil no longo prazo e se ela pode ser adaptada facilmente para futuras mudanças no sistema. É importante também criar abstrações que sejam simples, claras e facilmente compreensíveis.</p>
<h2>Referências</h2>
<ul>
<li><a href="https://www.amazon.com.br/Pragmatic-Programmer-Journeyman-Master/dp/020161622X">The Pragmatic Programmer</a></li>
<li><a href="https://www.amazon.com.br/Refactoring-Improving-Design-Existing-Code/dp/0134757599/ref=pd_lpo_1?pd_rd_w=y2LPp&#x26;content-id=amzn1.sym.036a9a17-ef5c-4c87-bb2c-81a28b5a8e68&#x26;pf_rd_p=036a9a17-ef5c-4c87-bb2c-81a28b5a8e68&#x26;pf_rd_r=T1Z6DP66YJS241C8ZYSX&#x26;pd_rd_wg=NXa55&#x26;pd_rd_r=4883151e-42e5-403c-981f-c973bb258c03&#x26;pd_rd_i=0134757599&#x26;psc=1">Refactoring</a></li>
<li><a href="https://kentcdodds.com/blog/aha-programming">AHA Programming</a></li>
<li><a href="https://dev.to/wuz/stop-trying-to-be-so-dry-instead-write-everything-twice-wet-5g33">Stop trying to be so DRY, instead Write Everything Twice (WET)</a></li>
<li><a href="https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction">The Wrong Abstraction</a></li>
</ul>
]]></content:encoded>
            <author>mauriciobw17@gmail.com (Maurício Witter)</author>
            <category domain="https://rwietterc.xyz">tech</category>
            <enclosure length="0" type="image/jpeg" url="https://res.cloudinary.com/ddwnioveu/image/upload/v1685324727/Tech_012_b658827d91.jpg"/>
        </item>
        <item>
            <title><![CDATA[Fluxo bidirecional no React com useImperativeHandle]]></title>
            <link>https://rwietterc.xyz/blog/article/fluxo-bidirecional-no-react-com-o-hook-use-imperative-handle</link>
            <guid>fluxo-bidirecional-no-react-com-o-hook-use-imperative-handle</guid>
            <pubDate>Mon, 25 Apr 2022 11:59:22 GMT</pubDate>
            <description><![CDATA[Expondo uma função de um componente child para o componente owner no React]]></description>
            <content:encoded><![CDATA[<h3>Introdução</h3>
<p>Olá 👋</p>
<p>Hoje vamos falar de fluxos unidirecional e bidirecional no Nextjs. Por padrão, no React, os dados fluem de uma maneira: do <em>owner</em> para o <em>child</em>, ou seja, no fluxo unidirecional, mas por vezes precisamos acessar determinada função ou realizar uma mudança de estado em um componente <em>child</em> pelo componente <em>owner</em>, isto é, de forma bidirecional, expondo um dado do componente inferior para o superior.</p>
<p><img src="https://raw.githubusercontent.com/rwietter/gatsby-blog/master/static/bidirecional.png" alt="fluxo bidirecional de dados dos componentes React. Componente owner passando uma propriedade ref para o componente child"></p>
<p>Para resolver isso, podemos elevar o estado (<em>Lifting State Up</em>) de um componente <em>child</em> para um componente <em>owner</em> que irá conter a lógica do componente <em>child</em>. Outra forma é utilizar a <em>Context API</em> ou outro gerenciador de estado global para compartilhamento de estado.  Mas, também podemos expor uma função ou estado para o componente <em>owner</em> por meio do <em>hook</em> <code>useImperativeHandle</code> e o <em>hook</em> <code>useRef</code> passando a referência da propriedade para o componente <em>owner</em>. Vamos ver como isso funciona.</p>
<p>Conforme a documentação do React diz sobre o <em>hook</em> <code>useImperativeHandle</code>:</p>
<blockquote>
<p>O <em>hook</em> <code>useImperativeHandle</code> personaliza o valor da instância que está exposta aos componentes <em>owner</em> ao usar <code>ref</code>. Como sempre, na maioria dos casos, seria bom evitar um código imperativo usando refs.</p>
</blockquote>
<p>E sobre o <em>hook</em> <code>useRef</code>:</p>
<blockquote>
<p><code>useRef</code> retorna um objeto <code>ref</code> mutável, no qual a propriedade <code>current</code> é inicializada para o argumento passado (<code>initialValue</code>). O objeto retornado persistirá durante todo o ciclo de vida do componente.</p>
</blockquote>
<p>Ou seja, o <em>hook</em> <code>useRef</code> cria um objeto mutável que recebe um valor inicial no qual podemos mudar durante o ciclo de vida do componente, já o <em>hook</em>  <code>useImperativeHandle</code> vai nos ajudar a expor nossa propriedade para o componente superior de forma imperativa utilizando essa referência.</p>
<h3>Vamos ao exemplo prático</h3>
<p>Vamos começar criando um <em>app</em> com o <em>framework</em> <em>Nextjs</em>. Rode no seu terminal os comandos abaixo para criar o projeto, em seguida entre no diretório e execute a aplicação.</p>
<pre><code># crie o projeto
yarn create next-app --typescript

# entre no diretório criado
cd my-app

# compila e executa o projeto em http://localhost:3000
yarn dev
</code></pre>
<p>Projeto criado! Agora, vamos até o <code>index.tsx</code> em <code>/pages/index.tsx</code> e vamos remover o código desnecessário, deixe como no exemplo abaixo.</p>
<pre><code>import type { NextPage } from 'next'

const Home: NextPage = () => {
  return (
    &#x3C;div>
 
    &#x3C;/div>
  )
}

export default Home
</code></pre>
<p>Vamos criar nosso componente <code>Modal</code>. Crie um diretório <code>components</code> na raiz do projeto e dentro dele um diretório <code>modal</code> e crie um arquivo <code>index.tsx</code>. Dentro do componente modal adicione uma <code>label</code> e um <code>input</code> com a lógica de abrir o modal quando o estado for verdadeiro (<em>Short Circuit Evaluation</em>).</p>
<pre><code>// components/modal/index.tsx
import { useState } from "react";

const Modal: React.FC = () => {
  const [isModalOpen, setIsModalOpen] = useState(false);
  
  return (
    &#x3C;>
      {isModalOpen &#x26;&#x26; (
        &#x3C;div className="modal">
          &#x3C;label htmlFor="nome">Qual o seu nome ?&#x3C;/label>
          &#x3C;input name="nome" />
        &#x3C;/div>
      )}
    &#x3C;/>
  );
};

export default Modal;
</code></pre>
<p>Vamos importar o <code>Modal</code> no componente <code>Home</code> e adicionar um botão logo abaixo que vai disparar um evento ao receber um <code>click</code>. Esse evento precisa mudar o estado do modal para <code>true</code> para que seja exibido em tela. Logo, precisamos referenciar a função que troca o estado do modal para o componente <code>Home</code>.</p>
<pre><code>import type { NextPage } from 'next'
import Modal from '../components/modal'

const Home: NextPage = () => {
  return (
    &#x3C;main>
      &#x3C;Modal />
      &#x3C;button onClick={() => {}} className="open-modal-button">
        Open Modal
      &#x3C;/button>
    &#x3C;/main>
  )
}

export default Home
</code></pre>
<p>Antes vamos adicionar um estilo ao modal. Crie um arquivo de estilo <code>styles/modal.css</code>, esse estilo irá posicionar o modal sobre os outros elementos, centralizar seus componentes e adicionar uma largura e altura. Você pode copiar o CSS nesse <a href="https://github.com/rwietter/blog-posts/blob/main/my-app/styles/modal.css">link</a>.</p>
<p>No estilo <code>global.css</code> adicione o código abaixo para centralizar o conteúdo.</p>
<pre><code>/* styles/global.css */
main {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}
</code></pre>
<p>Agora basta importar o arquivo <code>modal.css</code>em <code>pages/_app.tsx</code>. Dessa forma o estilo já será aplicado ao nosso componente <code>Modal</code>.</p>
<pre><code>// pages/_app.tsx
import '../styles/globals.css';
import '../styles/modal.css';
</code></pre>
<p>Agora precisamos fazer o fluxo inverso, vamos referenciar a função que vai alterar o estado para que o componente <em>owner</em> possa acessar. No modal precisamos receber a referência que será criada no componente <em>owner</em>, essa referência é obtida como segundo parâmetro, também vamos adicionar o <strong>tipo</strong> aos nossos parâmetros com <em>generic types</em>.  Também, vamos expor a função <code>handleOpenModal</code> com o <em>hook</em> <code>useImperativeHandle</code>, como primeiro argumento ele recebe a referência criada no <em>owner</em>, como segundo argumento uma <em>callback</em> que irá retornar um objeto com nossa função que queremos acessar pela referência criada no <em>owner</em>. Por fim, vamos exportar o componente como argumento da função <code>forwardRef</code>, essa função irá encaminhar a referência ao componente <em>owner</em>.</p>
<pre><code>import {
  forwardRef,
  ForwardRefRenderFunction,
  ReactNode,
  useImperativeHandle,
  useState,
} from "react";

interface ModalProps {
  children?: ReactNode;
}

const Modal: ForwardRefRenderFunction&#x3C;ModalRef, ModalProps> = (props, ref) => {
  const [isModalOpen, setIsModalOpen] = useState(false);

  const handleOpenModal = () => setIsModalOpen((state) => !state);
  
  useImperativeHandle(ref, () => ({
    handleOpenModal,
  }));

  return (
    &#x3C;>
      {/* ... */}
    &#x3C;/>
  )
}

export default forwardRef(Modal);
</code></pre>
<p>Agora, no componente <code>Home</code>, precisamos criar a <code>ref</code> e repassar para o componente modal.  Utilizamos o <em>hook</em> <code>useRef</code> para criar uma <code>ref</code> e passamos como <em>generic type</em> a interface <code>ModalRef</code> que específica a função que iremos referenciar. Exporte essa interface e importe no componente Modal, pois precisamos adicionar o <em>type</em> que recebemos como atributo do componente.</p>
<pre><code>export interface ModalRef {
  handleOpenModal: () => void;
}

const Home: NextPage = () => {
  const modalRef = useRef&#x3C;ModalRef>(null);

  return (
    &#x3C;>
      &#x3C;Modal ref={modalRef} />
      &#x3C;button onClick={() => {}}>Open Modal&#x3C;/button>
    &#x3C;/>
  )
}

export default Home;
</code></pre>
<p>Ainda no componente <code>Home</code>, só precisamos criar uma função que irá receber a referência da função do <code>Modal</code> e repassar para a propriedade <code>onClick</code>. Feito isso, já iremos ter o modal funcional.</p>
<pre><code>const Home: NextPage = () => {
  const modalRef = useRef&#x3C;ModalRef>(null);
  const handleOpenModal = () => modalRef.current?.handleOpenModal();

  return (
    &#x3C;>
      &#x3C;Modal ref={modalRef} />
      &#x3C;button onClick={handleOpenModal}>Open Modal&#x3C;/button>
    &#x3C;/>
  )
}
</code></pre>
<p>Para finalizar, vamos adicionar um botão de <code>close</code> no modal para fechar quando estiver aberto.</p>
<pre><code>return (
  &#x3C;>
    {isModalOpen &#x26;&#x26; (
      &#x3C;div className="modal">
        &#x3C;label htmlFor="nome">Qual o seu nome ?&#x3C;/label>
        &#x3C;input name="nome" />
        &#x3C;button onClick={handleOpenModal}>Close&#x3C;/button>
      &#x3C;/div>
    )}
  &#x3C;/>
);
</code></pre>
<h3>Conclusão</h3>
<p>Essa é uma forma simples de alterar um estado quando não podemos ou não queremos criar a lógica de uma funcionalidade em um componente que não precisa saber dessa funcionalidade ou não queremos utilizar um gerenciador de estado.  Não é muito comum, nem recomendável utilizar código imperativo, mas quando necessário pode ser muito útil :)</p>
<p>Até mais ⚛ 👋</p>
<hr>
<h3>Referências</h3>
<ul>
<li><a href="https://pt-br.reactjs.org/docs/hooks-reference.html#useimperativehandle">Hook useImperativeHandle</a></li>
<li><a href="https://pt-br.reactjs.org/docs/hooks-reference.html#useref">Hook useRef</a></li>
<li><a href="https://pt-br.reactjs.org/docs/react-api.html#reactforwardref">ForwardRef</a></li>
<li><a href="https://github.com/rwietter/blog-posts/tree/main/my-app">Repositório do projeto</a></li>
</ul>
]]></content:encoded>
            <author>mauriciobw17@gmail.com (Maurício Witter)</author>
            <category domain="https://rwietterc.xyz">tech</category>
            <enclosure length="0" type="image/jpeg" url="https://res.cloudinary.com/ddwnioveu/image/upload/v1676138698/hubble_arp_madore608_333_potw2240a_1_36bdc3a340.jpg"/>
        </item>
    </channel>
</rss>