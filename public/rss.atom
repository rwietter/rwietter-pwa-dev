<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://rwietterc.xyz</id>
    <title>Maurício Witter | RSS Feed</title>
    <updated>2023-06-13T00:53:08.284Z</updated>
    <generator>Feed for Node.js</generator>
    <author>
        <name>Maurício Witter</name>
        <email>mauriciobw17@gmail.com</email>
        <uri>https://twitter.com/rwietter</uri>
    </author>
    <link rel="alternate" href="https://rwietterc.xyz"/>
    <link rel="self" href="https://rwietterc.xyz/rss.xml"/>
    <subtitle>RSS feed for Maurício Witter blog</subtitle>
    <logo>https://rwietterc.xyz/icons/mstile-310x310.png</logo>
    <icon>https://rwietterc.xyz/favicon.ico</icon>
    <rights>All rights reserved 2023, Maurício Witter</rights>
    <entry>
        <title type="html"><![CDATA[Preferir a duplicação sobre a abstração é realmente o melhor caminho ?]]></title>
        <id>https://rwietterc.xyz/blog/article/preferir-a-duplicacao-sobre-a-abstracao-e-realmente-o-melhor-caminho</id>
        <link href="https://rwietterc.xyz/blog/article/preferir-a-duplicacao-sobre-a-abstracao-e-realmente-o-melhor-caminho"/>
        <updated>2023-05-29T01:45:54.431Z</updated>
        <summary type="html"><![CDATA[A duplicação de código é algo muito ruim, uma abstração confusa é tão ruim quanto. Então qual seria a melhor abordagem para isso ?]]></summary>
        <content type="html"><![CDATA[Hoje vamos falar um pouco do princípio do desenvolvimento de software DRY (Don't Repeat Yourself) e suas implicações. O DRY é um princípio relacionado duplicação de código e abstrações. Falaremos sobre o conceito de Rule of Three proposto por [Martin Fowler](https://martinfowler.com/) no seu livro Refactoring, falaremos sobre o conceito AHA (Avoid Hasty Abstractions) proposto por [Kent C. Dodds](https://kentcdodds.com/) e, também, sobre conceito [WET](https://dev.to/wuz/stop-trying-to-be-so-dry-instead-write-everything-twice-wet-5g33) (Write Everything Twice) proposto por [Conlin Durbin](https://dev.to/wuz).

Antes de tudo, vamos ver um exemplo do que seria duplicação de código para entender a existência desses conceitos.

A duplicação de código (a.k.a copiar/colar), nada mais é do que **repetir o mesmo código em dois ou mais locais da base de código**, essa duplicação traz consigo uma **série de problemas**, entre eles, a **redundância de código, bugs no código repetido em diferentes componentes e a criação de bugs ao dar manutenção em uma das duplicações e esquecer a outra**.

Em Ciência da Computação, **a abstração é a simplificação de conceitos complexos e gerais em uma interface simples**, tornando-os mais fáceis de entender e manipular em diferentes contextos.

## O problema da duplicação

Suponha que temos 4 botões com CSS repetido em cada um deles, aí chega um requisito para mudar o background do botão e quem vai dar manutenção é outro desenvolvedor que não sabe se o código está repetido, onde está repetido e quantas vezes está repetido, já viu o problema não é ? Teremos botões de cor `#XXX` e botões de cor `#YYY`.

Agora, **imagine se o cenário não for um simples botão, mas algo crítico para o software** como a geração de JSON Web Token no login. Se esse código estiver repetido e alterarmos algo em um local em outro não, podemos ter problemas de vulnerabilidades ou diversos outros bugs que dependem do token.

A abstração errada, na realidade não passa de um código confuso e mal escrito. A abstração errada é uma abstração que não deveria existir. Então, seria melhor deixar o código repetido ao invés de fazer uma abstração complexa ? Talvez! Mas na maioria das vezes é apenas um erro de implementação ao definir várias responsabilidades a ela ou abstrair conhecimentos distintos.

## Princípios gerais

Então, quando devemos duplicar código e quando devemos abstrair ? Essas perguntas tem muitas respostas, mas nenhuma é realmente um padrão convencional que todos os desenvolvedores adotam.

### Don't Repeat Yourself

O DRY foi um princípio formulado por Andy Hunt e Dave Thomas, no livro [The Pragmatic Programmer](https://www.amazon.com.br/Pragmatic-Programmer-Journeyman-Master/dp/020161622X). Conforme os autores, o DRY surgiu para tentar resolver Os Males da Duplicação (The Evils of Duplication). Se você tem código duplicado, você precisa lembrar-se onde duplicou, mas não é uma questão de saber se você vai se lembrar: é uma questão de quando você vai esquecer, e a surpresa não será nada agradável quando acontecer.

Em outras palavras, quando você precisa alterar alguma coisa e o código está repetido por N vezes na sua base de código, então você terá que alterar em N lugares e isso nos leva ao problema descrito na seção 1.


> “Cada fragmento de conhecimento deve ter uma representação única, inequívoca e autoritária dentro de um sistema.” (The Pragmatic Programmer).

Conforme Hunt e Thomas, **um código que representa um conhecimento deve ter uma representação única, inequívoca e autoritária dentro de um sistema**. Isso significa que DRY não é apenas sobre não duplicar código, mas é, sobretudo, conhecimento.

Bem, mas o que isso significa ? Significa que dois códigos duplicados podem ser iguais no momento, mas que podem crescer com seus próprios requisitos e de forma diferente, ou seja, temos dois fragmentos com representações únicas de conhecimento, nesse caso não faz sentido criar uma abstração pois não viola o principio DRY e você pode acabar tendo uma abstração que representa instâncias de conhecimentos diferentes.

O DRY não específica quando é a hora de abstrair uma duplicação ou quando não abstrair, você simplesmente não deve repetir o mesmo conhecimento. Muitos desenvolvedores fazem abstrações precipitadas e acabam tendo uma abstração complexa que tem muitas responsabilidades, tornando o código pouco legível, manutenível e testável.

_Isso nos leva ao Rule of Three…_

### Rule of Three

Esse conceito foi proposto por Martin Fowler em seu livro Refactoring.

Você deve estar se perguntando o porquê de **três** ser especial. Geralmente você acaba tendo duas duplicações com uma ou outra leve particularidade e pode ser mantida assim caso você não saiba os requisitos futuros, mas quando há três duplicação é muito comum ter mais duplicações.


> “A primeira vez que você faz algo, você simplesmente faz. Na segunda vez que você faz algo semelhante, você pode ter calafrios com a duplicação, mas faz a duplicação de qualquer maneira. Na terceira vez que você fizer algo semelhante, você refatorará” (Martin Fowler - Refactoring).

Rule of Three diz que você pode duplicar o código por duas vezes, mas se você tiver que repetir pela terceira vez, então é hora de refatorar.

### Write Everything Twice

WET se assemelha ao conceito Rule of Three, WET tenta se afastar de otimizações prematuras e permite que você possa repetir código duas vezes mas não três. No entanto, aqui o sistema pode ser entendido como algo mais abstrato e a abstração depende do contexto.

Por exemplo, se você tem botões que se repetem em diferentes páginas, faz sentido você abstrair em um único componente. No entanto, se você tem duas páginas como /blog e /listas que recebem um conjunto de dados e renderizam o título e descrição, não há essa necessidade pois são componentes de conhecimento distintos.

Conlin Durbin enfatiza que em caso de duplicação, você deve comentar sobre elas, para quando ocorrer um problema ou tiver que fazer uma abstração, seja mais fácil encontrá-las.

### Avoid Hasty Abstractions

Enfim, chegamos ao AHA que se pronúncia “Aha!” e pode se entendido como “Evite abstrações precipitadas”. Esse conceito foi proposto por Kent C. Dodds em um [artigo](https://kentcdodds.com/blog/aha-programming) no ano de 2020. Na mesma linha, Dodds sugere que **devemos evitar abstrações precipitadas pois não sabemos todos os requisitos de um sistema de antemão**, tanto que pode mudar e evoluir e você acaba com uma [abstração errada](https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction), conforme cita Sandi Metz.

> “Otimize primeiro, faça a mudança depois.” (Kent C. Dodds - AHA).

AHA da mais flexibilidade e não impõe regras de duplicações para refatorar e abstrair, mas ressalta que a importância do DRY para não virar um caos absoluto. Primeiramente, diante de duplicações, deve-se **otimizá-las antes de mudar no sentido de abstrair com clareza**. Quanto a questão de quando mudar, **você pode mudar quando sentir-se confiante com os casos de uso**.

## Adaptação

A duplicação de código incorre em um custo muito alto na maioria das vezes, mesmo que seja no máximo duas duplicações. Talvez, se o problema é abstração mal feita, então o problema é de implementação. Algo que deve resolver isso é entender como DRY trata conhecimento, para não criarmos abstrações com diversas responsabilidades. Ou seja, se você tem uma abstração que está tomando rumos diferentes, caia fora dessa abstração e faça outra que atende aos requisitos do novo recurso.

Por exemplo, temos o **ComponenteA** e o **ComponenteB**, eles são uma duplicação de código com um padrão em comum e mesmo conhecimento, então criamos a AbstraçãoX de forma simples e flexível por padrão (Imagem 1). Digamos que o ComponenteB precisa mudar e é preciso modificar a AbstraçãoX, de tal modo que adicionamos mais responsabilidade e que não é usada no ComponenteA, ou seja, isso já **deixou de ter o mesmo conhecimento** e possivelmente trará problemas futuros. Para resolver isso, vamos separar a AbstraçãoX em AbstraçãoX e AbstraçãoY ou desfazer as abstrações e retornar aos Componentes A e B.

![b55d6170-0684-4f19-9f93-480f96b242b3_1344x1306.webp](https://res.cloudinary.com/ddwnioveu/image/upload/v1685323229/b55d6170_0684_4f19_9f93_480f96b242b3_1344x1306_a053b70020.webp)
.

Dessa forma, podemos resolver a questão de abstrair sem ter que lidar duplicações. Particularmente, as duplicações em uma base de código grande são bem custosas. Assim, para lidarmos com abstrações erradas, analisamos o contexto e o conhecimento, quando não faz mais sentido essa abstração, removemos a abstração. Não precisamos ter que duplicar código uma, duas ou três vezes a espera de abstrair e evitar dores de cabeça.

**Essa é só outra visão, portanto, fica a sua escolha testar e verificar qual se sai melhor pra você.**

### Além disso…

**Evite abstrações excessivamente genéricas**, as abstrações podem ser tão genéricas que perdem sua utilidade. Por exemplo, criar uma abstração de "Animal" para um sistema que só tem um tipo de objeto “Cachorro” pode ser excessivamente genérico e não agregar valor. As abstrações devem ser específicas e relevantes para o problema que se está tentando resolver.

**Evite a duplicação de código em testes**, seus testes devem ser tão DRY quanto possível e evite duplicar código em vários testes.

Para a evolução do software, **as abstrações devem ser flexíveis o suficiente para lidar com mudanças no sistema** e permitir que o software evolua sem muita dor.

No que tange a legibilidade do código, **as abstrações devem tornar o código mais legível e não o contrário**.

## Para concluir

Criar abstrações é complicado e requer um bom entendimento do problema a ser resolvido. Se uma abstração não for bem projetada, ela pode acabar sendo mais difícil de entender e manter do que o próprio código duplicado.

No entanto, isso não significa que a duplicação de código seja a melhor alternativa. A duplicação pode levar a problemas de manutenção, como correções duplicadas ou código obsoleto, além de dificultar a leitura e a compreensão do código. A duplicação aumenta o risco de erros, pois, se uma correção é feita em um lugar, pode ser esquecido de ser feito em outro lugar onde o código é duplicado.

A solução para evitar a duplicação de código e ainda assim criar abstrações úteis é encontrar o equilíbrio certo entre abstração e detalhes de implementação. É importante pensar em como a abstração pode ser útil no longo prazo e se ela pode ser adaptada facilmente para futuras mudanças no sistema. É importante também criar abstrações que sejam simples, claras e facilmente compreensíveis.

## Referências

- [The Pragmatic Programmer](https://www.amazon.com.br/Pragmatic-Programmer-Journeyman-Master/dp/020161622X)
- [Refactoring](https://www.amazon.com.br/Refactoring-Improving-Design-Existing-Code/dp/0134757599/ref=pd_lpo_1?pd_rd_w=y2LPp&content-id=amzn1.sym.036a9a17-ef5c-4c87-bb2c-81a28b5a8e68&pf_rd_p=036a9a17-ef5c-4c87-bb2c-81a28b5a8e68&pf_rd_r=T1Z6DP66YJS241C8ZYSX&pd_rd_wg=NXa55&pd_rd_r=4883151e-42e5-403c-981f-c973bb258c03&pd_rd_i=0134757599&psc=1)
- [AHA Programming](https://kentcdodds.com/blog/aha-programming)
- [Stop trying to be so DRY, instead Write Everything Twice (WET)](https://dev.to/wuz/stop-trying-to-be-so-dry-instead-write-everything-twice-wet-5g33)
- [The Wrong Abstraction](https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction)

]]></content>
        <author>
            <name>Maurício Witter</name>
            <email>mauriciobw17@gmail.com</email>
            <uri>https://twitter.com/rwietter</uri>
        </author>
        <category label="tech" scheme="https://rwietterc.xyz" term="tech"/>
        <published>2023-05-29T01:45:54.431Z</published>
        <rights>All rights reserved 2023, Maurício Witter</rights>
    </entry>
    <entry>
        <title type="html"><![CDATA[Programação declarativa: por que você deveria conhecer ?]]></title>
        <id>https://rwietterc.xyz/blog/article/programacao-declarativa-por-que-voce-deveria-conhecer</id>
        <link href="https://rwietterc.xyz/blog/article/programacao-declarativa-por-que-voce-deveria-conhecer"/>
        <updated>2023-02-25T01:22:12.570Z</updated>
        <summary type="html"><![CDATA[Programação declarativa é uma abordagem legível, melhor de manter e paralelizar, que pode melhorar em muitos níveis o seu código.]]></summary>
        <content type="html"><![CDATA[> A prática da leitura crítica leva à habilidade de reescrever, no que lhe concerne, leva a uma escrita melhor (The Elements of Programming Style).

## Introdução

Sabemos que as linguagens de programação podem ser classificadas de diversas formas, por Paradigmas (Orientação a Objetos, Funcional, Procedural, Lógico, entre outros); também podem ser classificadas por type system forte e fraco; pelo nível de abstração (Machine code, Low level Assembler ou High level); se são compiladas ou interpretadas, ou então pelo estilo imperativo, ou declarativo. Esse último que iremos discutir neste artigo.

Entender o que são os estilos de programação, suas características e como se comportam vai ajudar você a entender melhor outros paradigmas como o Paradigma Funcional e Lógico, além de que com essa abordagem, você poderá se ater melhor ao design do seu código e escrever melhor.

Você já deve ter ouvido falar que a história da programação de computadores começou com computadores eletromecânicos — ou você pode considerar até antes disso — com a codificação de algoritmos por meio de cartões perfurados utilizando a Álgebra Booleana e Assembler lá pelas décadas de 30 e 40. As linguagens de programação comerciais também começaram a surgir nessas décadas seguintes.

Mas quanto ao estilo de programação, quando surgiu ? Bom, o estilo imperativo foi o primeiro estilo de codificação que surgiu, com as primeiras linguagens de estudo short code, esse estilo foi difundido por muito tempo já que ele é parecido com a nossa comunicação, tal como uma receita de bolo. Já o estilo declarativo não se tem uma data ou evento específico, mas surgiu em algum grau com a linguagem LISP (1958) e principalmente com o Prolog (1972), depois foi aprofundado em outras linguagens lógicas e funcionais como o Haskell (1990).

No lado das linguagens imperativas temos, por exemplo, FORTRAN, ALGOL, Pascal, Ada e C entre outras, já no lado da linguagens declarativas temos, por exemplo: HTML, CSS, YAML e SQL. É válido lembrar que as linguagens JavaScript, Java, PHP e Rust, por exemplo, seguem o paradigma imperativo mas incluem abstrações que você pode utilizar para tornar seu código mais declarativo.

## Estilo de Programação Imperativo

O estilo imperativo concentra-se em como executar o código detalhe a detalhe e define o fluxo de controle de como instruções alteram o estado de um programa. Para ficar mais claro, o código imperativo ordena comandos ao computador, diz exatamente o que precisa fazer, como precisa fazer e em que ordem exata precisa executar, de tal modo que não há abstrações.

A exemplo, o código abaixo é um algoritmo de ordenação chamado de bubble Sort que percorre o array N² vezes fazendo a troca dos elementos até ordená-lo completamente. Nesse código há a construção da lógica e fluxo de controle, além da mutabilidade do array.

![buble sort](https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F0a640f32-3aa6-4420-a048-16e4174e1a81_1348x1350.png)

O código imperativo serve a propósitos específicos como a programação de código de baixo nível para o qual existem poucas ou nenhuma abstração. Na maioria das vezes, tal estilo é verboso, ruim para depurar, ler e para dar manutenção, especialmente em grandes sistemas e equipes. Em um código imperativo há muitos loops, condicionais e mutações de estado que facilmente resultam em bugs.

Assim sendo, a programação imperativa é mais adequada para tarefas onde é importante controlar o estado do programa e gerenciar o fluxo de execução. Mas, vale ressaltar que a programação imperativa pode ser difícil de paralelizar.

Vamos a um exemplo prático onde utilizarei a linguagem Typescript. Vamos calcular o fatorial de um número natural positivo, cuja fórmula está na imagem abaixo.

![fatorail](https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Ff5c2b102-a99c-45d4-a8ee-71d106821de5_487x157.png)

Primeiramente, temos um código imperativo, onde avaliamos se N é menor ou igual a zero e retornamos 1, do contrário fazemos um loop até N-1 e multiplicamos o valor de N pelo índice fazendo a mutabilidade de N, ao final retornamos N. Perceba que nesse código nós programamos a lógica de calcular o fatorial de N, mas também programamos o fluxo de controle.

![fatorial imperativo](https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F36ca5586-ae84-49f3-9be8-23b7b7e716d9_1040x630.png)

Vejamos agora um exemplo de um fatorial que utiliza um conceito da programação funcional que se chama recursão, que nada mais é do que o processo de chamar uma função dentro dela mesma até que uma condição interrompa a execução. Nesse código abaixo do fatorial com recursão, nós abstraímos o fluxo de controle e definimos apenas a lógica do algoritmo. Primeiramente, temos a mesma condição de retornar 1 se o N for negativo ou igual a zero e depois retornamos N multiplicado pelo valor retornado pela chamada recursiva decrementando N em -1, isso será repetido até que N seja zero. Perceba que economizamos linhas de código e ficou bem mais legível.

![fatorial recursivo](https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5163b037-876f-43f8-a9b0-b78f597733c3_1040x450.png)

Mais a frente veremos outros exemplos utilizando outras abstrações que tornam o código imutável e conciso.

### Características do código Imperativo
- Execução sequencial;
- Estado mutável;
- Gerenciamento manual de memória;
- Não-determinístico.

### Vantagens
- Domínio explícito sobre o fluxo de controle;
- Eficiência em uso de memória (se utilizado corretamente);

### Desvantagens
- Código verboso;
- Mutabilidade de estado;
- Efeitos colaterais.

## Estilo de Programação Declarativo

O estilo declarativo, por outro lado, é um modelo de abstração de alto nível que está mais próximo do idioma inglês, tal que foi seu objetivo inicial. Nesse estilo, o programador vai declarar o que deve ser computado ao invés de como deve ser computado, vamos delegar a implementação de controle para a linguagem, para assim direcionar nossos esforços de programação e manutenção para a lógica e computabilidade.

Muitas linguagens que aplicam esse estilo tentam minimizar ou eliminar os efeitos colaterais descrevendo o que o programa deve realizar em termos do domínio do problema, em vez de descrever como realizá-lo como uma sequência das primitivas da linguagem de programação.

Conforme R. Kowalski em Communications of the ACM, Volume 22, Issue 7, July 1979, um algoritmo é composto pela lógica e pelo fluxo de controle. Na programação declarativa, a linguagem tende a abstrair a fluxo de controle e deixar para o programador desenvolver a lógica.

![algorithm](https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F649d082d-40e8-4567-b23f-3779291ec802_452x59.png)

Lloyd, JW. no artigo Practical advantages of declarative programming, explica que a programação declarativa pode ser entendida como “forte” e “fraca”. Isto é, no sentido “forte”, o programador só fornece a lógica do que precisa e no sentido “fraco”, o programador precisa fornecer a lógica e estender o fluxo de controle para computar o resultado esperado.

O paralelismo é um dos pilares da programação declarativa, assim como a abstração. A avaliação do resultado deve depender exclusivamente da entrada, pois dessa forma, evita-se o acoplamento e elimina efeitos colaterais.

![pilares da programação declarativa](https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F6c5f0443-0982-4134-bbd1-fd97b6465138_689x396.png)

### Características do código Declarativo
- Stateless (estado interno não é relembrado entre chamadas);
- Determinístico (as mesmas chamadas produzem os mesmos resultados);
- Paralelismo (execução de múltiplas tarefas simultaneamente);
- Transparência Referencial (uma expressão pode ser substituída por seu valor sem afetar o comportamento);
- Modelo semântico claro e conciso;
- Abstrações de alto nível;
- Independência.

### Vantagens
- Legibilidade;
- Concisão;
- Recuperação de erros;
- Reutilização;
- Comutatividade;
- Sem efeitos colaterais;
- Idempotência.

### Desvantagens
- Baixo nível de controle;
- Dificuldades de programação com estado (Stateful).

Tá, entendi que tem benefícios e tal. Mas, programar declarativamente significa apenas remover loops e condicionais do código ? É claro que não, você pode aplicar em diversas situações, lembre-se que programação declarativa não é apenas sobre abstração, mas sobre legibilidade também.

No exemplo abaixo temos um código que faz stream de um arquivo CSV. O código faz a conversão de um Node Stream para Web Stream. Primeiro, usamos um objeto Transform para converter o CSV em JSON e colocá-lo na fila para o próximo Transform pegar os pedaços de JSON e filtrar as propriedades. Por último, criamos um Writable Stream para escrever os dados na resposta da requisição. Perceba que esse código está bem ruim de ler, pois não da para ter muita noção do que faz o que aí.

![streams imperativo](https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb60a4836-82ae-494c-8636-7ce68198187e_1394x1440.png)

Agora, veremos uma maneira mais declarativa de fazer o mesmo código acima. Os passos seguem os mesmos, a diferença é que dividimos o código e adicionamos mais legibilidade a ele. Primeiramente, escrevemos cada função com a sua devida responsabilidade.

![streams funções](https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fb5303173-bd1b-41a6-8a4c-472286613aea_1840x1666.png)

Agora criamos o pipeline chamando as funções e repassando o resultado de uma função para a próxima. Convenhamos que, agora você bate o olho no código abaixo e já sabe o que ele faz, né ? Muito diferente do que aquele código anterior.

![streams pipeline](https://substackcdn.com/image/fetch/w_1272,c_limit,f_webp,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F774a8622-501d-4609-ab90-1fa4fe6711d2_1040x450.png)

A propósito, se quiser entender mais sobre streams, cola nesse [vídeo do Erick Wendel](https://www.youtube.com/watch?v=-IpRYbL4yMk&feature=youtu.be), do qual esse exemplo foi tirado.

## Use Cases

Você como Engenheiro de Software precisa conhecer bem as diversas classificações de linguagens e suas tecnologias para fazer boas escolhas e evitar tempo e dinheiro perdido. Na Engenharia de Software não existe bala de prata, portanto é necessário conhecer as caraterísticas em geral. Aqui estão alguns casos de uso para cada estilo, embora existem muitos outros cenários.

### Estilo Imperativo

- Sistemas de baixo nível: programação de sistemas de baixo nível, como drivers de dispositivo, sistemas operacionais e firmware. Essas tarefas requerem manipulação direta de locais de memória e registros de hardware, sendo melhor realizado usando um estilo imperativo.
- Jogos e simulações: jogos e simulações geralmente envolvem algoritmos complexos e atualizações em tempo real, sendo mais fáceis de expressar usando um estilo imperativo. A programação imperativa fornece controle explícito sobre o fluxo do programa, tornando mais fácil escrever mecanismos de jogo eficientes e simulações físicas.
- Operações de E/S: a programação imperativa é adequada para tarefas que envolvem muitos estados mutáveis ​​e efeitos colaterais, como operações de E/S. Programas imperativos podem manipular diretamente locais de memória e registros de dispositivos, tornando-os adequados para essas tarefas.

### Estilo Declarativo

- Desenvolvimento Web: a programação declarativa é frequentemente usada no desenvolvimento Web, onde HTML, CSS e outras linguagens de marcação são usadas para definir a estrutura e a aparência das páginas da Web. A programação declarativa permite que os desenvolvedores especifiquem a aparência da página, em vez de como obter essa aparência.
- Processamento de dados: a programação declarativa é adequada para tarefas de processamento de dados, como consultar bancos de dados e manipular grandes conjuntos de dados. Linguagens de programação declarativas como SQL fornecem uma interface de alto nível para interagir com dados, tornando mais fácil escrever consultas e transformações complexas.
- Programação funcional: a programação funcional enfatiza o uso de funções puras e estruturas de dados imutáveis. A programação funcional é adequada para tarefas que exigem muita simultaneidade ou paralelismo, pois funções puras não têm efeitos colaterais e podem ser executadas em paralelo com segurança.

## Estado da Arte

> A crescente popularidade das linguagens de programação declarativas decorre da simplicidade inerente do paradigma, cujo alto nível de abstração garante estilos de programação legíveis por humanos. — MOTTOLA A.. Design and implementation of a declarative programming language in a reactive environment. 2005.

Muitas das linguagens imperativas começaram a trazer novos recursos na última década para o estilo declarativo. Um exemplo é o Java 8 que trouce uma nova API para Streams para operar em coleções usando expressões lambda abstraindo o código imperativo, inclusive você pode encontrar uma comparação aqui.

No Front-end também ganhamos muito mais produtividade e segurança com os frameworks declarativos que surgiram nos últimos anos, como o React, o Vue, o Angular, o Next, o Nuxt entre outros.

Na área de cloud-computing, várias ferramentas no estilo declarativo como o Terraform, Ansible, Docker, Kubernets auxiliam a colocar aplicações em produção com escalabilidade, segurança e confiabilidade, fazendo o CI/CD.

## Conclusão

Não existe de fato uma linguagem puramente declarativa, o que torna um código declarativo ou imperativo é como ele é codificado. As linguagens que oferecem maiores recursos para programar no estilo declarativo são linguagens com os paradigmas lógico e funcional, pois se aproximam mais das características do estilo declarativo, embora o estilo depende da sua codificação como o uso de abstrações, imutabilidade, determinismo e transparência referencial.

Portanto, pense na hora de programar que seu algoritmo precisa de um lógica e um fluxo de controle, a partir daí, procure recursos na sua linguagem que abstraiam o fluxo de controle e deixe sob sua responsabilidade a implementação da lógica. Os benefícios disso são melhor legibilidade e segurança, pois você abstraiu detalhes menores de controle e também ganha interoperabilidade.

À medida que a programação declarativa continua a evoluir, é provável que ela desempenhe um papel cada vez mais importante no futuro do desenvolvimento de software. Portanto, aprender sobre programação declarativa pode ser um investimento valioso para qualquer desenvolvedor que deseja melhorar sua habilidade em criar código de alta qualidade e eficiente.

Se você chegou até aqui, espero que tenha tido uma ótima leitura e que esse conteúdo possa ter lhe ajudado de alguma forma. Obrigado por ler! Qualquer dúvida, agregação ou correção, deixe nos comentários 💚

## Referências

- [Declarative Programming](https://en.wikipedia.org/wiki/Declarative_programming#:~:text=Declarative%20programming%20is%20a%20non,by%20a%20declarative%20programming%20style.)
- [Algorithm = logic + control](https://dl.acm.org/doi/10.1145/359131.359136)
- [A Note on Declarative Programming Paradigms and the Future of Definitional Programming](https://www.cse.chalmers.se/~oloft/Papers/wm96.pdf)
- [Practical advantages of declarative programming](https://research-information.bris.ac.uk/en/publications/practical-advantages-of-declarative-programming)
- [CodeDocs - Declarative programming](https://codedocs.org/what-is/declarative-programming)
- [Imperative Programming in Depth](https://blog.ndepend.com/imperative-programming-in-depth/)]]></content>
        <author>
            <name>Maurício Witter</name>
            <email>mauriciobw17@gmail.com</email>
            <uri>https://twitter.com/rwietter</uri>
        </author>
        <category label="tech" scheme="https://rwietterc.xyz" term="tech"/>
        <published>2023-02-25T01:22:12.570Z</published>
        <rights>All rights reserved 2023, Maurício Witter</rights>
    </entry>
    <entry>
        <title type="html"><![CDATA[Fluxo bidirecional no React com useImperativeHandle]]></title>
        <id>https://rwietterc.xyz/blog/article/fluxo-bidirecional-no-react-com-o-hook-use-imperative-handle</id>
        <link href="https://rwietterc.xyz/blog/article/fluxo-bidirecional-no-react-com-o-hook-use-imperative-handle"/>
        <updated>2022-04-25T11:59:22.126Z</updated>
        <summary type="html"><![CDATA[Expondo uma função de um componente child para o componente owner no React]]></summary>
        <content type="html"><![CDATA[### Introdução

Olá 👋

Hoje vamos falar de fluxos unidirecional e bidirecional no Nextjs. Por padrão, no React, os dados fluem de uma maneira: do *owner* para o *child*, ou seja, no fluxo unidirecional, mas por vezes precisamos acessar determinada função ou realizar uma mudança de estado em um componente *child* pelo componente *owner*, isto é, de forma bidirecional, expondo um dado do componente inferior para o superior.

![fluxo bidirecional de dados dos componentes React. Componente owner passando uma propriedade ref para o componente child](https://raw.githubusercontent.com/rwietter/gatsby-blog/master/static/bidirecional.png)

Para resolver isso, podemos elevar o estado (*Lifting State Up*) de um componente *child* para um componente *owner* que irá conter a lógica do componente *child*. Outra forma é utilizar a *Context API* ou outro gerenciador de estado global para compartilhamento de estado.  Mas, também podemos expor uma função ou estado para o componente *owner* por meio do *hook* `useImperativeHandle` e o *hook* `useRef` passando a referência da propriedade para o componente *owner*. Vamos ver como isso funciona.

Conforme a documentação do React diz sobre o *hook* `useImperativeHandle`:

> O *hook* `useImperativeHandle` personaliza o valor da instância que está exposta aos componentes *owner* ao usar `ref`. Como sempre, na maioria dos casos, seria bom evitar um código imperativo usando refs.

E sobre o *hook* `useRef`:

> `useRef` retorna um objeto `ref` mutável, no qual a propriedade `current` é inicializada para o argumento passado (`initialValue`). O objeto retornado persistirá durante todo o ciclo de vida do componente.

Ou seja, o *hook* `useRef` cria um objeto mutável que recebe um valor inicial no qual podemos mudar durante o ciclo de vida do componente, já o *hook*  `useImperativeHandle` vai nos ajudar a expor nossa propriedade para o componente superior de forma imperativa utilizando essa referência.

### Vamos ao exemplo prático

Vamos começar criando um *app* com o *framework* *Nextjs*. Rode no seu terminal os comandos abaixo para criar o projeto, em seguida entre no diretório e execute a aplicação.

```shell
# crie o projeto
yarn create next-app --typescript

# entre no diretória criado
cd my-app

# compila e executa o projeto em localhost
yarn dev

# abra no navegador o endereço http://localhost:3000
```

Projeto criado! Agora, vamos até o `index.tsx` em `/pages/index.tsx` e vamos remover o código desnecessário, deixe como no exemplo abaixo.

```tsx
import type { NextPage } from 'next'

const Home: NextPage = () => {
  return (
    <div>
 
    </div>
  )
}

export default Home
```

Vamos criar nosso componente `Modal`. Crie um diretório `components` na raiz do projeto e dentro dele um diretório `modal` e crie um arquivo `index.tsx`. Dentro do componente modal adicione uma `label` e um `input` com a lógica de abrir o modal quando o estado for verdadeiro (*Short Circuit Evaluation*).

```tsx
// components/modal/index.tsx
import { useState } from "react";

const Modal: React.FC = () => {
  const [isModalOpen, setIsModalOpen] = useState(false);
  
  return (
    <>
      {isModalOpen && (
        <div className="modal">
          <label htmlFor="nome">Qual o seu nome ?</label>
          <input name="nome" />
        </div>
      )}
    </>
  );
};

export default Modal;
```

Vamos importar o `Modal` no componente `Home` e adicionar um botão logo abaixo que vai disparar um evento ao receber um `click`. Esse evento precisa mudar o estado do modal para `true` para que seja exibido em tela. Logo, precisamos referenciar a função que troca o estado do modal para o componente `Home`.

```tsx
import type { NextPage } from 'next'
import Modal from '../components/modal'

const Home: NextPage = () => {
  return (
    <main>
      <Modal />
      <button onClick={() => {}} className="open-modal-button">
        Open Modal
      </button>
    </main>
  )
}

export default Home
```

Antes vamos adicionar um estilo ao modal. Crie um arquivo de estilo `styles/modal.css`, esse estilo irá posicionar o modal sobre os outros elementos, centralizar seus componentes e adicionar uma largura e altura. Você pode copiar o CSS nesse [link](https://github.com/rwietter/blog-posts/blob/main/my-app/styles/modal.css).

No estilo `global.css` adicione o código abaixo para centralizar o conteúdo.

```css
/* styles/global.css */
main {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}
```

Agora basta importar o arquivo `modal.css`em `pages/_app.tsx`. Dessa forma o estilo já será aplicado ao nosso componente `Modal`.

```tsx
// pages/_app.tsx
import '../styles/globals.css';
import '../styles/modal.css';
```

Agora precisamos fazer o fluxo inverso, vamos referenciar a função que vai alterar o estado para que o componente *owner* possa acessar. No modal precisamos receber a referência que será criada no componente *owner*, essa referência é obtida como segundo parâmetro, também vamos adicionar o **tipo** aos nossos parâmetros com *generic types*.  Também, vamos expor a função `handleOpenModal` com o *hook* `useImperativeHandle`, como primeiro argumento ele recebe a referência criada no *owner*, como segundo argumento uma *callback* que irá retornar um objeto com nossa função que queremos acessar pela referência criada no *owner*. Por fim, vamos exportar o componente como argumento da função `forwardRef`, essa função irá encaminhar a referência ao componente *owner*.

```tsx
import {
  forwardRef,
  ForwardRefRenderFunction,
  ReactNode,
  useImperativeHandle,
  useState,
} from "react";

interface ModalProps {
  children?: ReactNode;
}

const Modal: ForwardRefRenderFunction<ModalRef, ModalProps> = (props, ref) => {
  const [isModalOpen, setIsModalOpen] = useState(false);

  const handleOpenModal = () => setIsModalOpen((state) => !state);
  
  useImperativeHandle(ref, () => ({
    handleOpenModal,
  }));

  return (
    <>
      {/* ... */}
    </>
  )
}

export default forwardRef(Modal);
```

Agora, no componente `Home`, precisamos criar a `ref` e repassar para o componente modal.  Utilizamos o *hook* `useRef` para criar uma `ref` e passamos como *generic type* a interface `ModalRef` que específica a função que iremos referenciar. Exporte essa interface e importe no componente Modal, pois precisamos adicionar o *type* que recebemos como atributo do componente. 

```tsx
export interface ModalRef {
  handleOpenModal: () => void;
}

const Home: NextPage = () => {
  const modalRef = useRef<ModalRef>(null);

  return (
    <>
      <Modal ref={modalRef} />
      <button onClick={() => {}}>Open Modal</button>
    </>
  )
}

export default Home;
```

Ainda no componente `Home`, só precisamos criar uma função que irá receber a referência da função do `Modal` e repassar para a propriedade `onClick`. Feito isso, já iremos ter o modal funcional. 

```tsx
const Home: NextPage = () => {
  const modalRef = useRef<ModalRef>(null);
  const handleOpenModal = () => modalRef.current?.handleOpenModal();

  return (
    <>
      <Modal ref={modalRef} />
      <button onClick={handleOpenModal}>Open Modal</button>
    </>
  )
}
```

Para finalizar, vamos adicionar um botão de `close` no modal para fechar quando estiver aberto. 

```tsx
return (
  <>
    {isModalOpen && (
      <div className="modal">
        <label htmlFor="nome">Qual o seu nome ?</label>
        <input name="nome" />
        <button onClick={handleOpenModal}>Close</button>
      </div>
    )}
  </>
);
```

### Conclusão

Essa é uma forma simples de alterar um estado quando não podemos ou não queremos criar a lógica de uma funcionalidade em um componente que não precisa saber dessa funcionalidade ou não queremos utilizar um gerenciador de estado.  Não é muito comum, nem recomendável utilizar código imperativo, mas quando necessário pode ser muito útil :)

Até mais ⚛ 👋

- - -

### Referências

* [Hook useImperativeHandle](https://pt-br.reactjs.org/docs/hooks-reference.html#useimperativehandle)
* [Hook useRef](https://pt-br.reactjs.org/docs/hooks-reference.html#useref)
* [ForwardRef](https://pt-br.reactjs.org/docs/react-api.html#reactforwardref)
* [Repositório do projeto](https://github.com/rwietter/blog-posts/tree/main/my-app)]]></content>
        <author>
            <name>Maurício Witter</name>
            <email>mauriciobw17@gmail.com</email>
            <uri>https://twitter.com/rwietter</uri>
        </author>
        <category label="tech" scheme="https://rwietterc.xyz" term="tech"/>
        <published>2022-04-25T11:59:22.126Z</published>
        <rights>All rights reserved 2023, Maurício Witter</rights>
    </entry>
</feed>